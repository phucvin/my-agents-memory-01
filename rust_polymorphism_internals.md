# Rust Polymorphism Internals

Rust implements polymorphism primarily through two mechanisms: **Static Dispatch** (via Generics) and **Dynamic Dispatch** (via Trait Objects). Understanding the internal difference is key to writing performance-critical code.

## 1. Static Dispatch (Monomorphization)

When you use generics in Rust, the compiler performs **monomorphization**. This means it generates a unique copy of the function for each concrete type used.

### Example
```rust
trait Speak {
    fn say(&self);
}

fn make_speak<T: Speak>(item: T) {
    item.say();
}
```

If you call `make_speak` with a `Dog` and a `Cat`, the compiler generates two functions internally, roughly equivalent to:
- `fn make_speak_for_dog(item: Dog)`
- `fn make_speak_for_cat(item: Cat)`

### Internals
- **Mechanism**: The call site is hard-coded to the specific function address. The compiler knows exactly which function to call at compile time.
- **Performance**: Fastest possible execution (inlining is possible).
- **Cost**: Larger binary size due to code duplication.

## 2. Dynamic Dispatch (Trait Objects)

When you use trait objects (e.g., `&dyn Speak` or `Box<dyn Speak>`), Rust uses **Type Erasure**. The compiler doesn't know the concrete type at compile time, so it must determine which method to call at runtime.

### Example
```rust
fn make_speak_dyn(item: &dyn Speak) {
    item.say();
}
```

### Internals: The Fat Pointer
A reference to a concrete type (`&Dog`) is a "thin pointer" (just the memory address, e.g., 64 bits).
A reference to a trait object (`&dyn Speak`) is a **"fat pointer"** (or wide pointer). It consists of two components (128 bits on 64-bit systems):

1.  **Data Pointer**: Points to the actual instance data (the `Dog` struct).
2.  **Vtable Pointer**: Points to the "Virtual Method Table" (vtable) specific to the implementation of that trait for that concrete type.

### The Vtable
The vtable is a static structure generated by the compiler for each `Impl Trait for Type` pair. It typically contains:
- Pointer to the destructor (`drop`).
- Size and alignment of the concrete type.
- Pointers to the implementation of each method in the trait.

When `item.say()` is called on a trait object:
1.  The program follows the vtable pointer.
2.  It looks up the address of the `say` function inside the vtable.
3.  It calls that function pointer, passing the data pointer as `self`.

### Performance
- **Slower**: Requires pointer indirection and prevents inlining.
- **Flexible**: Allows collections of different types (`Vec<Box<dyn Speak>>`).
